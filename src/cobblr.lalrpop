#![allow(clippy::all)]

use crate::ast::*;

grammar;

pub Program: crate::ast::Program = {
    Declarations => crate::ast::Program(Declarations)
};

pub Declarations: Vec<crate::ast::Decl> = {
    => vec![],
    <ds:Declarations> <d:Declaration> => {
        let mut v = ds;
        v.push(d);
        v
    }
};

pub Declaration: crate::ast::Decl = {
    FunctionDecl => FunctionDecl,
    StructDecl => StructDecl,
    EnumDecl => EnumDecl,
    TraitDecl => TraitDecl,
    ImplDecl => ImplDecl,
    LetDecl => LetDecl,
    ImportDecl => ImportDecl,
    DeriveAttrStruct => DeriveAttrStruct
};

pub ImportDecl: crate::ast::Decl = {
    "use" <path:Path> ";" => crate::ast::Decl::Import(path),
    "import" <path:Path> ";" => crate::ast::Decl::Import(path)
};

pub Path: crate::ast::Path = {
    <id:Identifier> => crate::ast::Path::Single(id),
    <p:Path> "::" <id:Identifier> => crate::ast::Path::Nested(Box::new(p), id)
};

pub DeriveAttrStruct: crate::ast::Decl = {
    "#derive" "(" <ids:IdentifierList> ")" <s:StructDecl> =>
        crate::ast::Decl::DerivedStruct(ids, Box::new(s))
};

pub IdentifierList: Vec<String> = {
    <id:Identifier> => vec![id],
    <ids:IdentifierList> "," <id:Identifier> => {
        let mut v = ids;
        v.push(id);
        v
    }
};

Identifier: String = {
    <id:r"[a-zA-Z_][a-zA-Z0-9_]*"> => id.to_string()
};

// === STRUCTS ===
pub StructDecl: crate::ast::Decl = {
    "struct" <id:Identifier> "{" <members:StructBody> "}" =>
        crate::ast::Decl::Struct(id, members)
};

StructBody: Vec<crate::ast::StructMember> = {
    => vec![],
    <body:StructBody> <m:StructMember> => {
        let mut v = body;
        v.push(m);
        v
    }
};

StructMember: crate::ast::StructMember = {
    <id:Identifier> ":" <ty:TypeExpr> ";" =>
        crate::ast::StructMember::field(id, ty),
    <id:Identifier> ":" <ty:TypeExpr> "=" <e:Expr> ";" =>
        crate::ast::StructMember::field_init(id, ty, e)
};

// === ENUMS ===
EnumDecl: crate::ast::Decl = {
    "enum" <id:Identifier> "{" <variants:EnumVariants> "}" =>
        crate::ast::Decl::Enum(id, variants)
};

EnumVariants: Vec<(String, Option<Vec<TypeExpr>>)> = {
    => vec![],
    <v:EnumVariants> <v2:EnumVariant> => {
        let mut vec = v;
        vec.push(v2);
        vec
    }
};

EnumVariant: (String, Option<Vec<TypeExpr>>) = {
    <id:Identifier> "," => (id, None),
    <id:Identifier> "(" <types:TypeList> ")" ","? => (id, Some(types))
};

// === TRAITS ===
TraitDecl: crate::ast::Decl = {
    "trait" <id:Identifier> "{" <methods:TraitMethods> "}" =>
        crate::ast::Decl::Trait(id, methods)
};

TraitMethods: Vec<crate::ast::TraitMethod> = {
    => vec![],
    <ms:TraitMethods> <m:TraitMethod> => {
        let mut v = ms;
        v.push(m);
        v
    }
};

TraitMethod: crate::ast::TraitMethod = {
    "fn" <id:Identifier> "(" <params:ParamList> ")" ";" =>
        crate::ast::TraitMethod::sig(id, params)
};

// === IMPL ===
ImplDecl: crate::ast::Decl = {
    "impl" <id:Identifier> "{" <body:ImplBody> "}" =>
        crate::ast::Decl::Impl(id, body),
    "impl" <trait_name:Identifier> "for" <struct_name:Identifier> "{" <body:ImplBody> "}" =>
        crate::ast::Decl::ImplTrait(trait_name, struct_name, body)
};

ImplBody: Vec<crate::ast::Decl> = {
    => vec![],
    <b:ImplBody> <f:FunctionDecl> => {
        let mut v = b;
        v.push(f);
        v
    }
};

pub FunctionDecl: crate::ast::Decl = {
    "fn" <id:Identifier> "(" <params:ParamList> ")" <body:Block> =>
        crate::ast::Decl::Function(id, params, None, body),
    "fn" <id:Identifier> "(" <params:ParamList> ")" "->" <ret_ty:TypeExpr> <body:Block> =>
        crate::ast::Decl::Function(id, params, Some(ret_ty), body),
    "async" "fn" <id:Identifier> "(" <params:ParamList> ")" <body:Block> =>
        crate::ast::Decl::AsyncFunction(id, params, None, body),
    "async" "fn" <id:Identifier> "(" <params:ParamList> ")" "->" <ret_ty:TypeExpr> <body:Block> =>
        crate::ast::Decl::AsyncFunction(id, params, Some(ret_ty), body)
};

pub ParamList: Vec<crate::ast::Param> = {
    => vec![],
    <p:Param> => vec![p],
    <ps:ParamList> "," <p:Param> => {
        let mut v = ps;
        v.push(p);
        v
    }
};

Param: crate::ast::Param = {
    <id:Identifier> ":" <ty:TypeExpr> =>
        crate::ast::Param { name: id, ty, is_mut: false },
    "&mut" <id:Identifier> ":" <ty:TypeExpr> =>
        crate::ast::Param { name: id, ty, is_mut: true }
};

pub LetDecl: crate::ast::Decl = {
    "let" <id:Identifier> "=" <e:Expr> ";" => crate::ast::Decl::Let(id, None, e),
    "let" <id:Identifier> ":" <ty:TypeExpr> "=" <e:Expr> ";" => crate::ast::Decl::Let(id, Some(ty), e),
    "let" "mut" <id:Identifier> "=" <e:Expr> ";" => crate::ast::Decl::LetMut(id, None, e),
    "let" "mut" <id:Identifier> ":" <ty:TypeExpr> "=" <e:Expr> ";" => crate::ast::Decl::LetMut(id, Some(ty), e)
};

pub Block: crate::ast::Block = {
    "{" <stmts:StatementList> <ret:MaybeImplicitReturn> "}" =>
        crate::ast::Block { statements: stmts, implicit_return: ret }
};

pub StatementList: Vec<crate::ast::Stmt> = {
    => vec![],
    <ss:StatementList> <s:Statement> => {
        let mut v = ss;
        v.push(s);
        v
    }
};

pub Statement: crate::ast::Stmt = {
    LetDecl => crate::ast::Stmt::LetDecl(LetDecl),
    Expr ";" => crate::ast::Stmt::ExprStmt(Expr),
    "return" Expr ";" => crate::ast::Stmt::Return(Expr),
    IfStmt => crate::ast::Stmt::If(IfStmt),
    "while" Expr Block => crate::ast::Stmt::While(Expr, Block),
    "loop" <b:Block> => crate::ast::Stmt::Loop(b),
    "break" ";" => crate::ast::Stmt::Break,
    "for" <id:Identifier> "in" <e:Expr> <b:Block> => crate::ast::Stmt::For(id, e, b)
};

IfStmt: crate::ast::IfStmt = {
    "if" <cond:Expr> <then:Block> => crate::ast::IfStmt { cond: Box::new(cond), then_branch: then, else_branch: None },
    "if" <cond:Expr> <then:Block> "else" <else_block:Block> => crate::ast::IfStmt { cond: Box::new(cond), then_branch: then, else_branch: Some(else_block) }
};

pub MaybeImplicitReturn: Option<Expr> = {
    => None,
    <e:Expr> => Some(e)
};

MatchExpr: crate::ast::Expr = {
    "match" <value:Expr> "{" <arms:MatchArms> "}" =>
        crate::ast::Expr::Match { value: Box::new(value), arms }
};

MatchArms: Vec<crate::ast::MatchArm> = {
    => vec![],
    <v:MatchArms> <arm:MatchArm> => {
        let mut vec = v;
        vec.push(arm);
        vec
    }
};

MatchArm: crate::ast::MatchArm = {
    <pat:Pattern> "=>" <body:Block> ","? => crate::ast::MatchArm { pattern: pat, body }
};

Pattern: crate::ast::Pattern = {
    Identifier => crate::ast::Pattern::Var(Identifier),
    NumberInt => crate::ast::Pattern::Number(NumberInt),
    NumberFloat => crate::ast::Pattern::Number(NumberFloat),
    "_" => crate::ast::Pattern::Wildcard,
    "Some" "(" <p:Pattern> ")" => crate::ast::Pattern::Some(Box::new(p)),
    "None" => crate::ast::Pattern::None,
    <variant:Identifier> "(" <p:Pattern> ")" => crate::ast::Pattern::Variant(variant, Box::new(p))
};

pub TypeExpr: crate::ast::TypeExpr = {
    "i64" => crate::ast::TypeExpr::Int64,
    "i32" => crate::ast::TypeExpr::Int32,
    "f64" => crate::ast::TypeExpr::Float64,
    "bool" => crate::ast::TypeExpr::Bool,
    "string" => crate::ast::TypeExpr::String,
    <id:Identifier> => crate::ast::TypeExpr::Custom(id),
    <id:Identifier> "<" <types:TypeList> ">" => crate::ast::TypeExpr::Generic(id, types),
    "(" <t:TypeExpr> ")" => t
};

TypeList: Vec<crate::ast::TypeExpr> = {
    <t:TypeExpr> => vec![t],
    <ts:TypeList> "," <t:TypeExpr> => { let mut v = ts; v.push(t); v }
};

NumberInt: crate::ast::Number::Int = {
    <n:r"-?[0-9]+"> => crate::ast::Number::Int(n.parse().unwrap())
};

NumberFloat: crate::ast::Number::Float = {
    <n:r"-?[0-9]+\.[0-9]+"> => crate::ast::Number::Float(n.parse().unwrap())
};

String: String = {
    <s: r#""([^"\\]|\\.)*""#> => s[1..s.len()-1].to_string()
};

ArgList: Vec<crate::ast::Expr> = {
    => vec![],
    <e:Expr> => vec![e],
    <args:ArgList> "," <e:Expr> => { let mut v = args; v.push(e); v }
};

StructLiteral: (String, Vec<(String, Expr)>) = {
    <name:Identifier> "{" <fields:FieldList> "}" => (name, fields)
};

FieldList: Vec<(String, Expr)> = {
    => vec![],
    <field:FieldInit> => vec![field],
    <fields:FieldList> "," <field:FieldInit> => { let mut v = fields; v.push(field); v }
};

FieldInit: (String, Expr) = {
    <id:Identifier> ":" <e:Expr> => (id, e)
};

Closure: crate::ast::Expr = {
    "|" <params:ParamNames> "|" <e:Expr> =>
        crate::ast::Expr::Closure(params, Box::new(e))
};

ParamNames: Vec<String> = {
    => vec![],
    <id:Identifier> => vec![id],
    <ps:ParamNames> "," <id:Identifier> => { let mut v = ps; v.push(id); v }
};

pub Expr: crate::ast::Expr = {
    #[precedence(level="1")]
    NumberInt => crate::ast::Expr::Number(NumberInt),
    NumberFloat => crate::ast::Expr::Number(NumberFloat),
    String => crate::ast::Expr::String(String),
    Identifier => crate::ast::Expr::Identifier(Identifier),
    
    #[precedence(level="1")]
    Closure => Closure,
    
    #[precedence(level="2")]
    "(" <e:Expr> ")" => e,
    
    #[precedence(level="2")]
    <lit:StructLiteral> => {
        let (name, fields) = lit;
        crate::ast::Expr::StructLit(name, fields)
    },
    
    #[precedence(level="2")]
    <id:Identifier> "::" <method:Identifier> "(" <args:ArgList> ")" =>
        crate::ast::Expr::AssocCall(id, method, args),
    
    #[precedence(level="2")]
    <id:Identifier> "(" <args:ArgList> ")" => crate::ast::Expr::Call(id, args),
    
    #[precedence(level="2")]
    <obj:Expr> "." <method:Identifier> "(" <args:ArgList> ")" =>
        crate::ast::Expr::MethodCall(Box::new(obj), method, args),
    
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => crate::ast::Expr::Mul(Box::new(l), Box::new(r)),
    <l:Expr> "/" <r:Expr> => crate::ast::Expr::Div(Box::new(l), Box::new(r)),

    #[precedence(level="4")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => crate::ast::Expr::Add(Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Expr> => crate::ast::Expr::Sub(Box::new(l), Box::new(r)),
    <l:Expr> "++" <r:Expr> => crate::ast::Expr::Concat(Box::new(l), Box::new(r)),

    #[precedence(level="5")] #[assoc(side="none")]
    <l:Expr> "==" <r:Expr> => crate::ast::Expr::Equal(Box::new(l), Box::new(r)),
    <l:Expr> "!=" <r:Expr> => crate::ast::Expr::NotEqual(Box::new(l), Box::new(r)),
    <l:Expr> "<" <r:Expr> => crate::ast::Expr::Less(Box::new(l), Box::new(r)),
    <l:Expr> "<=" <r:Expr> => crate::ast::Expr::LessEq(Box::new(l), Box::new(r)),
    <l:Expr> ">" <r:Expr> => crate::ast::Expr::Greater(Box::new(l), Box::new(r)),
    <l:Expr> ">=" <r:Expr> => crate::ast::Expr::GreaterEq(Box::new(l), Box::new(r)),

    MatchExpr => MatchExpr
};