use crate::ast;
use crate::ast::{
    Program,
    Decl,
    Param,
    StructMember,
    TraitMethod,
    Block,
    Stmt,
    IfStmt,
    Expr,
    Number,
    MatchArm,
    Pattern,
    TypeExpr,
};
use crate::tokens::{Token, LexicalError};

grammar;

pub Program: ast::Program = {
    <ds:Declarations> => crate::ast::Program(ds)
};

pub Declarations: Vec<ast::Decl> = {
    => vec![],
    <ds:Declarations> <d:Declaration> => {
        let mut v = ds;
        v.push(d);
        v
    }
};

pub Declaration: ast::Decl = {
    <fd:FunctionDecl> => fd,
    <sd:StructDecl> => sd,
    <ed:EnumDecl> => ed,
    <td:TraitDecl> => td,
    <ip:ImplDecl> => ip,
    <ld:LetDecl> => ld,
    <id:ImportDecl> => id,
    <da:DeriveAttrStruct> => da 
};

pub ImportDecl: ast::Decl = {
    "use" <path:Path> ";" => ast::Decl::Import(path),
    "import" <path:Path> ";" => ast::Decl::Import(path)
};

pub Path: ast::Path = {
    <id:"identifier"> => ast::Path::Single(id),
    <p:Path> "::" <id:"identifier"> => ast::Path::Nested(Box::new(p), id)
};

pub DeriveAttrStruct: ast::Decl = {
    "#derive" "(" <ids:IdentifierList> ")" <s:StructDecl> =>
        ast::Decl::DerivedStruct(ids, Box::new(s))
};

pub IdentifierList: Vec<String> = {
    <id:"identifier"> => vec![id],
    <ids:IdentifierList> "," <id:"identifier"> => {
        let mut v = ids;
        v.push(id);
        v
    }
};

pub StructDecl: ast::Decl = {
    "struct" <id:"identifier"> "{" <members:StructBody> "}" =>
        ast::Decl::Struct(id, vec![], members),
    "struct" <id:"identifier"> "<" <gps:IdentifierList> ">" "{" <members:StructBody> "}" =>
        ast::Decl::Struct(id, gps, members)
};

StructBody: Vec<ast::StructMember> = {
    => vec![],
    <body:StructBody> <m:StructMember> => {
        let mut v = body;
        v.push(m);
        v
    }
};

StructMember: ast::StructMember = {
    <id:"identifier"> ":" <ty:TypeExpr> "," =>
        ast::StructMember::field(id, ty),
    <id:"identifier"> ":" <ty:TypeExpr> "=" <e:Expr> "," =>
        ast::StructMember::field_init(id, ty, e)
};

EnumDecl: ast::Decl = {
    "enum" <id:"identifier"> "{" <variants:EnumVariants> "}" =>
        ast::Decl::Enum(id, variants)
};

EnumVariants: Vec<(String, Option<Vec<TypeExpr>>)> = {
    => vec![],
    <v:EnumVariants> <v2:EnumVariant> => {
        let mut vec = v;
        vec.push(v2);
        vec
    }
};

EnumVariant: (String, Option<Vec<TypeExpr>>) = {
    <id:"identifier"> "," => (id, None),
    <id:"identifier"> "(" <types:TypeList> ")" ","? => (id, Some(types))
};

TraitDecl: ast::Decl = {
    "trait" <id:"identifier"> "{" <methods:TraitMethods> "}" =>
        ast::Decl::Trait(id, methods)
};

TraitMethods: Vec<ast::TraitMethod> = {
    => vec![],
    <ms:TraitMethods> <m:TraitMethod> => {
        let mut v = ms;
        v.push(m);
        v
    }
};

TraitMethod: ast::TraitMethod = {
    "fn" <id:"identifier"> "(" <params:ParamList> ")" ";" =>
        ast::TraitMethod::sig(id, params)
};

ImplDecl: ast::Decl = {
    "impl" <id:"identifier"> "{" <body:ImplBody> "}" =>
        ast::Decl::Impl(id, body),
    "impl" <trait_name:"identifier"> "for" <struct_name:"identifier"> "{" <body:ImplBody> "}" =>
        ast::Decl::ImplTrait(trait_name, struct_name, body)
};

ImplBody: Vec<ast::Decl> = {
    => vec![],
    <b:ImplBody> <f:FunctionDecl> => {
        let mut v = b;
        v.push(f);
        v
    }
};
pub FunctionDecl: ast::Decl = {
    "fn" <id:"identifier"> "(" <params:ParamList> ")" <body:Block> =>
        ast::Decl::Function(id, vec![params], None, body),
    "fn" <id:"identifier"> "(" <params:ParamList> ")" "->" <ret_ty:TypeExpr> <body:Block> =>
        ast::Decl::Function(id, vec![params], Some(ret_ty), body),
    "fn" <id:"identifier"> "<" <_g:IdentifierList> ">" "(" <params:ParamList> ")" <body:Block> =>
        ast::Decl::Function(id, vec![params], None, body), // AST: you may store g into AST if you want
    "fn" <id:"identifier"> "<" <_g:IdentifierList> ">" "(" <params:ParamList> ")" "->" <ret_ty:TypeExpr> <body:Block> =>
        ast::Decl::Function(id, vec![params], Some(ret_ty), body),
    "fn" <id:"identifier"> "(" <params:ParamList> ")" "(" <params2:ParamList> ")" <body:Block> =>
        ast::Decl::Function(id, vec![params, params2], None, body),
    "fn" <id:"identifier"> "(" <params:ParamList> ")" "(" <params2:ParamList> ")" "->" <ret_ty:TypeExpr> <body:Block> =>
        ast::Decl::Function(id, vec![params, params2], Some(ret_ty), body),
    "async" "fn" <id:"identifier"> "(" <params:ParamList> ")" <body:Block> =>
        ast::Decl::AsyncFunction(id, vec![params], None, body),
    "async" "fn" <id:"identifier"> "(" <params:ParamList> ")" "->" <ret_ty:TypeExpr> <body:Block> =>
        ast::Decl::AsyncFunction(id, vec![params], Some(ret_ty), body)
};

pub ParamList: Vec<ast::Param> = {
    => vec![],
    <p:Param> => vec![p],
    <ps:ParamList> "," <p:Param> => {
        let mut v = ps;
        v.push(p);
        v
    }
};

TypeList: Vec<ast::TypeExpr> = {
    <t:TypeExpr> => vec![t],
    <ts:TypeList> "," <t:TypeExpr> => {
        let mut v = ts;
        v.push(t);
        v
    }
};

Param: ast::Param = {
    <id:"identifier"> ":" <ty:TypeExpr> =>
        ast::Param { name: id, ty, is_mut: false },
    "&" "mut" <id:"identifier"> ":" <ty:TypeExpr> =>
        ast::Param { name: id, ty, is_mut: true }
};

pub LetDecl: ast::Decl = {
    "let" <id:"identifier"> "=" <e:Expr> ";" => ast::Decl::Let(id, None, e),
    "let" <id:"identifier"> ":" <ty:TypeExpr> "=" <e:Expr> ";" => ast::Decl::Let(id, Some(ty), e),
    "let" "mut" <id:"identifier"> "=" <e:Expr> ";" => ast::Decl::LetMut(id, None, e),
    "let" "mut" <id:"identifier"> ":" <ty:TypeExpr> "=" <e:Expr> ";" => ast::Decl::LetMut(id, Some(ty), e)
};

pub Block: ast::Block = {
    "{" <stmts:StatementList> <ret:MaybeImplicitReturn> "}" =>
        ast::Block { statements: stmts, implicit_return: ret }
};

pub StatementList: Vec<ast::Stmt> = {
    => vec![],
    <ss:StatementList> <s:Statement> => {
        let mut v = ss;
        v.push(s);
        v
    }
};

pub Statement: ast::Stmt = {
    <ld:LetDecl> => ast::Stmt::LetDecl(ld),
    <e:Expr> ";" => ast::Stmt::ExprStmt(e),
    "return" <e:Expr> ";" => ast::Stmt::Return(e),
    <is:IfStmt> => ast::Stmt::If(is),
    "while" <e:Expr> <b:Block> => ast::Stmt::While(e, b),
    "loop" <b:Block> => ast::Stmt::Loop(b),
    "break" ";" => ast::Stmt::Break,
    "for" <id:"identifier"> "in" <e:Expr> <b:Block> => ast::Stmt::For(id, e, b),
    <m:MatchExpr> => ast::Stmt::Match(m)
};

IfStmt: ast::IfStmt = {
    "if" <cond:Expr> <then:Block> => ast::IfStmt { cond: Box::new(cond), then_branch: then, else_branch: None },
    "if" <cond:Expr> <then:Block> "else" <else_block:Block> => ast::IfStmt { cond: Box::new(cond), then_branch: then, else_branch: Some(else_block) }
};

pub MaybeImplicitReturn: Option<Expr> = {
    => None,
    <e:Expr> => Some(e)
};

MatchExpr: ast::Expr = {
    "match" <value:Expr> "{" <arms:MatchArms> "}" =>
        ast::Expr::Match { value: Box::new(value), arms }
};

MatchArms: Vec<ast::MatchArm> = {
    => vec![],
    <v:MatchArms> <arm:MatchArm> => {
        let mut vec = v;
        vec.push(arm);
        vec
    }
};

MatchArm: ast::MatchArm = {
    <pat:Pattern> "=>" <body:Block> ","? => ast::MatchArm { pattern: pat, body }
};

Pattern: ast::Pattern = {
    <id:"identifier"> => ast::Pattern::Var(id),
    <i:"int"> => ast::Pattern::Number(ast::Number::Int(i)),
    <f:"float"> => ast::Pattern::Number(ast::Number::Float(f)),
    "_" => ast::Pattern::Wildcard,
    "Some" "(" <p:Pattern> ")" => ast::Pattern::Some(Box::new(p)),
    "None" => ast::Pattern::None,
    <variant:"identifier"> "(" <p:Pattern> ")" => ast::Pattern::Variant(variant, Box::new(p))
};

BoolLit: bool = {
    "true" => true,
    "false" => false
};

pub TypeExpr: ast::TypeExpr = {
    "&" <t:TypeExpr> => ast::TypeExpr::Reference(Box::new(t)),
    "&" "mut" <t:TypeExpr> => ast::TypeExpr::MutableReference(Box::new(t)),
    "int" => ast::TypeExpr::Int64,
    "float" => ast::TypeExpr::Float64,
    "string" => ast::TypeExpr::String,
    BoolLit => ast::TypeExpr::Bool,    // or ast::TypeExpr::Bool(true) depending on your AST
    <id:"identifier"> => ast::TypeExpr::Custom(id),
    <id:"identifier"> "<" <types:TypeList> ">" => ast::TypeExpr::Generic(id, types),
    "(" <t:TypeExpr> ")" => t
};

Bool: ast::Bool = {
    "true" => ast::Bool::True,
    "false" => ast::Bool::False,
}

ArgList: Vec<ast::Expr> = {
    => vec![],
    <e:Expr> => vec![e],
    <args:ArgList> "," <e:Expr> => { let mut v = args; v.push(e); v }
};

StructLiteral: (String, Vec<(String, Expr)>) = {
    <name:"identifier"> "<-" "(" <fields:FieldList> ")" => (name, fields)
};

FieldList: Vec<(String, Expr)> = {
    => vec![],
    <field:FieldInit> => vec![field],
    <fields:FieldList> "," <field:FieldInit> => { let mut v = fields; v.push(field); v }
};

FieldInit: (String, Expr) = {
    <id:"identifier"> ":" <e:Expr> => (id, e)
};

pub Expr: ast::Expr = {
    #[precedence(level="0")]
    Postfix,

    #[precedence(level="1")]
    #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => ast::Expr::Mul(Box::new(l), Box::new(r)),
    <l:Expr> "/" <r:Expr> => ast::Expr::Div(Box::new(l), Box::new(r)),

    #[precedence(level="2")]
    #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => ast::Expr::Add(Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Expr> => ast::Expr::Sub(Box::new(l), Box::new(r)),
    <l:Expr> "++" <r:Expr> => ast::Expr::Concat(Box::new(l), Box::new(r)),

    #[precedence(level="3")]
    #[assoc(side="left")]
    <l:Expr> "==" <r:Expr> => ast::Expr::Equal(Box::new(l), Box::new(r)),
    <l:Expr> "!=" <r:Expr> => ast::Expr::NotEqual(Box::new(l), Box::new(r)),
    <l:Expr> "<"  <r:Expr> => ast::Expr::Less(Box::new(l), Box::new(r)),
    <l:Expr> "<=" <r:Expr> => ast::Expr::LessEq(Box::new(l), Box::new(r)),
    <l:Expr> ">"  <r:Expr> => ast::Expr::Greater(Box::new(l), Box::new(r)),
    <l:Expr> ">=" <r:Expr> => ast::Expr::GreaterEq(Box::new(l), Box::new(r)),

    #[precedence(level="4")] #[assoc(side="left")]
    <l:Expr> "|>" <r:Expr> => ast::Expr::Pipe(Box::new(l), Box::new(r)),

}

Postfix: ast::Expr = {
    Atom,
    <l:Postfix> "::" <id:"identifier"> => ast::Expr::FieldAccess(Box::new(l), id),
    <l:Postfix> "(" <args:ArgList> ")" => ast::Expr::Call(Box::new(l), args),
    <l:Postfix> "[" <idx:Expr> "]" => ast::Expr::Index(Box::new(l), Box::new(idx)),
    <l:Postfix> "." <field:"identifier"> => ast::Expr::DotAccess(Box::new(l), field),
}

Atom: ast::Expr = {
    "|" <params:ParamList> "|" "{" <body:Expr> "}" => ast::Expr::Closure(params, Box::new(body)),
    "|" <params:ParamList> "|" <body:Expr> "end" => ast::Expr::Closure(params, Box::new(body)),
    <s:StructLiteral> => {
        let (name, fields) = s;
        ast::Expr::StructLit(name, fields)
    },
    //MatchExpr,
    Primary,
}

TupleExpr: ast::Expr = {
    "(" <e:Expr> ")" => e, // grouping expression
    "(" <list:TupleList> ")" => ast::Expr::Tuple(list)
};

TupleList: Vec<ast::Expr> = {
    <e:Expr> "," <list:ArgList> => {
        let mut v = vec![e];
        v.extend(list);
        v
    }
};

TupleType: ast::TypeExpr = {
    "(" <t:TypeExpr> ")" => t,
    "(" <list:TupleTypeList> ")" => ast::TypeExpr::Tuple(list),
};

TupleTypeList: Vec<ast::TypeExpr> = {
    <t:TypeExpr> "," <ts:TypeList> => {
        let mut v = vec![t];
        v.extend(ts);
        v
    }
};

Primary: ast::Expr = {
    "&" <e:Primary> => ast::Expr::Reference(Box::new(e)),
    "&" "mut" <e:Primary> => ast::Expr::MutReference(Box::new(e)),
    <n:"int"> => ast::Expr::Number(ast::Number::Int(n)),
    <f:"float"> => ast::Expr::Number(ast::Number::Float(f)),
    <s:"string"> => ast::Expr::String(s),
    <id:"identifier"> => ast::Expr::Identifier(id),
    "Some" "(" <e:Expr> ")" => ast::Expr::Variant("Some".to_string(), Some(Box::new(e))),
    "None" => ast::Expr::Variant("None".to_string(), None),
    "Ok" "(" <e:Expr> ")" => ast::Expr::Variant("Ok".to_string(), Some(Box::new(e))),
    "Err" "(" <e:Expr> ")" => ast::Expr::Variant("Err".to_string(), Some(Box::new(e))),
    "(" <e:Expr> ")" => e
}

// LEXER DEFINITION
extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "let" => Token::Let,
    "mut" => Token::Mut,
    "fn" => Token::Fn,
    "struct" => Token::Struct,
    "enum" => Token::Enum,
    "impl" => Token::Impl,
    "async" => Token::Async,
    "await" => Token::Await,
    "if" => Token::If,
    "else" => Token::Else,
    "for" => Token::For,
    "while" => Token::While,
    "loop" => Token::Loop,
    "break" => Token::Break,
    "continue" => Token::Continue,
    "return" => Token::Return,
    "match" => Token::Match,
    "Some" => Token::Some,
    "None" => Token::None,
    "Ok" => Token::Ok,
    "Err" => Token::Err,
    "use" => Token::Use,
    "in" => Token::In,
    "import" => Token::Import,
    "trait" => Token::Trait,
    "end" => Token::End,
    "#derive" => Token::Derive,
    "::" => Token::DoubleColon,
    ":" => Token::Colon,
    "." => Token::Dot,
    ".." => Token::DotDot,
    ";" => Token::Semi,
    "," => Token::Comma,
    "_" => Token::Underscore,
    "=" => Token::Equals,
    "+" => Token::Plus,
    "-" => Token::Minus,
    "*" => Token::Star,
    "/" => Token::Slash,
    "++" => Token::PlusPlus,
    "|" => Token::Pipe,
    "|>" => Token::PipeForward,
    "->" => Token::Arrow,
    "<-" => Token::LArrow,
    "=>" => Token::FatArrow,
    "&" => Token::And,
    "&&" => Token::AndAnd,
    "||" => Token::OrOr,
    "==" => Token::EqualEqual,
    "!=" => Token::NotEqual,
    "<=" => Token::LessEqual,
    ">=" => Token::GreaterEqual,
    "<" => Token::Less,
    ">" => Token::Greater,
    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBrack,
    "]" => Token::RBrack,
    "int" => Token::Int(<i64>),
    "float" => Token::Float(<f64>),
    "string" => Token::Str(<String>),
    "identifier" => Token::Identifier(<String>),
    "true" => Token::True,
    "false" => Token::False,
  }
}
