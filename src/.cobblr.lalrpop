use crate::ast::*;
use std::str::FromStr;

grammar;

pub Program: ast::Program = {
    Declarations => crate::ast::Program(Declarations)
};

pub Declarations: Vec<ast::Decl> = {
    => vec![],
    <ds:Declarations> <d:Declaration> => {
        let mut v = ds;
        v.push(d);
        v
    }
};

pub Declaration: ast::Decl = {
    FunctionDecl => FunctionDecl,
    StructDecl => StructDecl,
    EnumDecl => EnumDecl,
    TraitDecl => TraitDecl,
    ImplDecl => ImplDecl,
    LetDecl => LetDecl,
    ImportDecl => ImportDecl,
    DeriveAttrStruct => DeriveAttrStruct
};

pub ImportDecl: ast::Decl = {
    "use" <path:Path> ";" => ast::Decl::Import(path),
    "import" <path:Path> ";" => ast::Decl::Import(path)
};

pub Path: ast::Path = {
    <id:Identifier> => ast::Path::Single(id),
    <p:Path> "::" <id:Identifier> => ast::Path::Nested(Box::new(p), id)
};

pub DeriveAttrStruct: ast::Decl = {
    "#derive" "(" <ids:IdentifierList> ")" <s:StructDecl> =>
        ast::Decl::DerivedStruct(ids, Box::new(s))
};

pub IdentifierList: Vec<String> = {
    <id:Identifier> => vec![id],
    <ids:IdentifierList> "," <id:Identifier> => {
        let mut v = ids;
        v.push(id);
        v
    }
};

Identifier: String = {
    <id: r"[a-zA-Z_][a-zA-Z0-9_]*"> => id.to_string()
};

pub StructDecl: ast::Decl = {
    "struct" <id:Identifier> "{" <members:StructBody> "}" =>
        ast::Decl::Struct(id, members)
};

StructBody: Vec<ast::StructMember> = {
    => vec![],
    <body:StructBody> <m:StructMember> => {
        let mut v = body;
        v.push(m);
        v
    }
};

StructMember: ast::StructMember = {
    <id:Identifier> ":" <ty:TypeExpr> ";" =>
        ast::StructMember::field(id, ty),
    <id:Identifier> ":" <ty:TypeExpr> "=" <e:Expr> ";" =>
        ast::StructMember::field_init(id, ty, e)
};

EnumDecl: ast::Decl = {
    "enum" <id:Identifier> "{" <variants:EnumVariants> "}" =>
        ast::Decl::Enum(id, variants)
};

EnumVariants: Vec<(String, Option<Vec<TypeExpr>>)> = {
    => vec![],
    <v:EnumVariants> <v2:EnumVariant> => {
        let mut vec = v;
        vec.push(v2);
        vec
    }
};

EnumVariant: (String, Option<Vec<TypeExpr>>) = {
    <id:Identifier> "," => (id, None),
    <id:Identifier> "(" <types:TypeList> ")" ","? => (id, Some(types))
};

TraitDecl: ast::Decl = {
    "trait" <id:Identifier> "{" <methods:TraitMethods> "}" =>
        ast::Decl::Trait(id, methods)
};

TraitMethods: Vec<ast::TraitMethod> = {
    => vec![],
    <ms:TraitMethods> <m:TraitMethod> => {
        let mut v = ms;
        v.push(m);
        v
    }
};

TraitMethod: ast::TraitMethod = {
    "fn" <id:Identifier> "(" <params:ParamList> ")" ";" =>
        ast::TraitMethod::sig(id, params)
};

ImplDecl: ast::Decl = {
    "impl" <id:Identifier> "{" <body:ImplBody> "}" =>
        ast::Decl::Impl(id, body),
    "impl" <trait_name:Identifier> "for" <struct_name:Identifier> "{" <body:ImplBody> "}" =>
        ast::Decl::ImplTrait(trait_name, struct_name, body)
};

ImplBody: Vec<ast::Decl> = {
    => vec![],
    <b:ImplBody> <f:FunctionDecl> => {
        let mut v = b;
        v.push(f);
        v
    }
};

pub FunctionDecl: ast::Decl = {
    "fn" <id:Identifier> "(" <params:ParamList> ")" <body:Block> =>
        ast::Decl::Function(id, params, None, body),
    "fn" <id:Identifier> "(" <params:ParamList> ")" "->" <ret_ty:TypeExpr> <body:Block> =>
        ast::Decl::Function(id, params, Some(ret_ty), body),
    "async" "fn" <id:Identifier> "(" <params:ParamList> ")" <body:Block> =>
        ast::Decl::AsyncFunction(id, params, None, body),
    "async" "fn" <id:Identifier> "(" <params:ParamList> ")" "->" <ret_ty:TypeExpr> <body:Block> =>
        ast::Decl::AsyncFunction(id, params, Some(ret_ty), body)
};

pub ParamList: Vec<ast::Param> = {
    => vec![],
    <p:Param> => vec![p],
    <ps:ParamList> "," <p:Param> => {
        let mut v = ps;
        v.push(p);
        v
    }
};

Param: ast::Param = {
    <id:Identifier> ":" <ty:TypeExpr> =>
        ast::Param { name: id, ty, is_mut: false },
    "&mut" <id:Identifier> ":" <ty:TypeExpr> =>
        ast::Param { name: id, ty, is_mut: true }
};

pub LetDecl: ast::Decl = {
    "let" <id:Identifier> "=" <e:Expr> ";" => ast::Decl::Let(id, None, e),
    "let" <id:Identifier> ":" <ty:TypeExpr> "=" <e:Expr> ";" => ast::Decl::Let(id, Some(ty), e),
    "let" "mut" <id:Identifier> "=" <e:Expr> ";" => ast::Decl::LetMut(id, None, e),
    "let" "mut" <id:Identifier> ":" <ty:TypeExpr> "=" <e:Expr> ";" => ast::Decl::LetMut(id, Some(ty), e)
};

pub Block: ast::Block = {
    "{" <stmts:StatementList> <ret:MaybeImplicitReturn> "}" =>
        ast::Block { statements: stmts, implicit_return: ret }
};

pub StatementList: Vec<ast::Stmt> = {
    => vec![],
    <ss:StatementList> <s:Statement> => {
        let mut v = ss;
        v.push(s);
        v
    }
};

pub Statement: ast::Stmt = {
    LetDecl => ast::Stmt::LetDecl(LetDecl),
    Expr ";" => ast::Stmt::ExprStmt(Expr),
    "return" Expr ";" => ast::Stmt::Return(Expr),
    IfStmt => ast::Stmt::If(IfStmt),
    "while" Expr Block => ast::Stmt::While(Expr, Block),
    "loop" <b:Block> => ast::Stmt::Loop(b),
    "break" ";" => ast::Stmt::Break,
    "for" <id:Identifier> "in" <e:Expr> <b:Block> => ast::Stmt::For(id, e, b)
};

IfStmt: ast::IfStmt = {
    "if" <cond:Expr> <then:Block> => ast::IfStmt { cond: Box::new(cond), then_branch: then, else_branch: None },
    "if" <cond:Expr> <then:Block> "else" <else_block:Block> => ast::IfStmt { cond: Box::new(cond), then_branch: then, else_branch: Some(else_block) }
};

pub MaybeImplicitReturn: Option<Expr> = {
    => None,
    <e:Expr> => Some(e)
};

MatchExpr: ast::Expr = {
    "match" <value:Expr> "{" <arms:MatchArms> "}" =>
        ast::Expr::Match { value: Box::new(value), arms }
};

MatchArms: Vec<ast::MatchArm> = {
    => vec![],
    <v:MatchArms> <arm:MatchArm> => {
        let mut vec = v;
        vec.push(arm);
        vec
    }
};

MatchArm: ast::MatchArm = {
    <pat:Pattern> "=>" <body:Block> ","? => ast::MatchArm { pattern: pat, body }
};

Pattern: ast::Pattern = {
    Identifier => ast::Pattern::Var(Identifier),
    Number => ast::Pattern::Number(Number),
    "_" => ast::Pattern::Wildcard,
    "Some" "(" <p:Pattern> ")" => ast::Pattern::Some(Box::new(p)),
    "None" => ast::Pattern::None,
    <variant:Identifier> "(" <p:Pattern> ")" => ast::Pattern::Variant(variant, Box::new(p))
};

Number: ast::Number = {
    <n:r"-?[0-9]+\.[0-9]+"> => ast::Number::Float(n.parse::<f64>().unwrap()),
    <n:r"-?[0-9]+"> => ast::Number::Int(n.parse::<i64>().unwrap())
};

pub TypeExpr: ast::TypeExpr = {
    "i64" => ast::TypeExpr::Int64,
    "f64" => ast::TypeExpr::Float64,
    "bool" => ast::TypeExpr::Bool,
    "string" => ast::TypeExpr::String,
    <id:Identifier> => ast::TypeExpr::Custom(id),
    <id:Identifier> "<" <types:TypeList> ">" => ast::TypeExpr::Generic(id, types),
    "(" <t:TypeExpr> ")" => t
};

TypeList: Vec<ast::TypeExpr> = {
    <t:TypeExpr> => vec![t],
    <ts:TypeList> "," <t:TypeExpr> => { let mut v = ts; v.push(t); v }
};



String: String = {
    <s: r#""([^"\\]|\\.)*""#> => s[1..s.len()-1].to_string()
};

ArgList: Vec<ast::Expr> = {
    => vec![],
    <e:Expr> => vec![e],
    <args:ArgList> "," <e:Expr> => { let mut v = args; v.push(e); v }
};

StructLiteral: (String, Vec<(String, Expr)>) = {
    <name:Identifier> "{" <fields:FieldList> "}" => (name, fields)
};

FieldList: Vec<(String, Expr)> = {
    => vec![],
    <field:FieldInit> => vec![field],
    <fields:FieldList> "," <field:FieldInit> => { let mut v = fields; v.push(field); }
};

FieldInit: (String, Expr) = {
    <id:Identifier> ":" <e:Expr> => (id, e)
};


//Closure: ast::Expr = {
//    "/" "|" <params:ParamNames> "|" <body:Expr> => ast::Expr::Closure(params, body),
//};

//ParamNames: Vec<String> = {
//    => vec![],
//    <id:Identifier> => vec![id],
//    <ps:ParamNames> "," <id:Identifier> => { let mut v = ps; v.push(id); v }
//};

//ExprAtom: ast::Expr = {
//    NumberInt => ast::Expr::Number::Int(NumberInt),
//    NumberFloat => ast::Expr::Number::Int(NumberInt),
//    String => ast::Expr::String(String),
//    "(" <e:Expr> ")" => e,
//    MatchExpr => MatchExpr,
//    <lit:StructLiteral> => {
//        let (name, fields) = lit;
//        ast::Expr::StructLit(name, fields)
//    }
//};

//Primary: ast::Expr = {
//    Closure => Closure,
//    <a:ExprAtom> => a
//};

Postfix: ast::Expr = {
    <id:Identifier> "(" <args:ArgList> ")" => ast::Expr::Call(id, args),
    <id:Identifier> => ast::Expr::Identifier(id),
//    <p:Primary> => p,
    <obj:Postfix> "." <method:Identifier> "(" <args:ArgList> ")" =>
        ast::Expr::MethodCall(Box::new(obj), method, args),
    <t:Identifier> "::" <method:Identifier> "(" <args:ArgList> ")" =>
        ast::Expr::AssocCall(t, method, args)
};

pub Expr: ast::Expr = {

    // Level 1: Multiplication / Division
    #[precedence(level="1")]
    <l:Expr> "*" <r:Postfix> => ast::Expr::Mul(Box::new(l), Box::new(r)),
    <l:Expr> "/" <r:Postfix> => ast::Expr::Div(Box::new(l), Box::new(r)),

    // Level 2: Addition / Subtraction / Concatenation (left-associative)
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => ast::Expr::Add(Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Expr> => ast::Expr::Sub(Box::new(l), Box::new(r)),
    <l:Expr> "++" <r:Expr> => ast::Expr::Concat(Box::new(l), Box::new(r)),

    // Level 3: Comparisons (non-associative)
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "==" <r:Expr> => ast::Expr::Equal(Box::new(l), Box::new(r)),
    <l:Expr> "!=" <r:Expr> => ast::Expr::NotEqual(Box::new(l), Box::new(r)),
    <l:Expr> "<"  <r:Expr> => ast::Expr::Less(Box::new(l), Box::new(r)),
    <l:Expr> "<=" <r:Expr> => ast::Expr::LessEq(Box::new(l), Box::new(r)),
    <l:Expr> ">"  <r:Expr> => ast::Expr::Greater(Box::new(l), Box::new(r)),
    <l:Expr> ">=" <r:Expr> => ast::Expr::GreaterEq(Box::new(l), Box::new(r)),
};
