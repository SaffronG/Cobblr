// parser.lalrpop
use crate::ast::*;
use crate::token::Token;

// Tell LALRPOP that our input type is your lexerâ€™s Token
pub type Tok = Token;

// ---------- Root ----------
Program: Program = {
    Declarations => Program(<>)
};

Declarations: Vec<Decl> = {
    Declaration+ => <>
};

Declaration: Decl = {
    FunctionDecl => <> ,
    StructDecl => <> ,
    LetDecl => <> ,
    ImportDecl => <> ,
    DeriveAttrStruct => <>
};

// ---------- Imports ----------
ImportDecl: Decl = {
    Token::KeywordUse Path ";" => Decl::Import(Path(<>)),
    Token::KeywordImport Path ";" => Decl::Import(Path(<>))
};

Path: Path = {
    <id:Identifier> => Path::Single(id),
    <path:Path> "::" <id:Identifier> => Path::Nested(Box::new(path), id)
};

// ---------- Attributes ----------
DeriveAttrStruct: Decl = {
    Token::KeywordDerive "(" IdentifierList ")" StructDecl =>
        Decl::DerivedStruct(IdentifierList, Box::new(StructDecl))
};

IdentifierList: Vec<String> = {
    Identifier ++ ","
};

// ---------- Structs ----------
StructDecl: Decl = {
    Token::KeywordStruct Identifier "{" StructBody "}" => Decl::Struct(Identifier, StructBody)
};

StructBody: Vec<StructMember> = {
    <members:StructMember*> => members
};

StructMember: StructMember = {
    Identifier ":" TypeExpr ";" => StructMember::Field(Identifier, TypeExpr),
    Identifier ":" TypeExpr "=" Expr ";" => StructMember::FieldDefault(Identifier, TypeExpr, Expr),
    FunctionDecl => StructMember::Method(FunctionDecl)
};

// ---------- Implementations ----------
ImplDecl: Decl = {
    Token::KeywordImpl Identifier "{" ImplBody "}" => Decl::Impl { target: Identifier, items: ImplBody },
    Token::KeywordImpl Identifier "for" Identifier "{" ImplBody "}" =>
        Decl::ImplTrait { trait_name: Identifier, target: Identifier, items: ImplBody }
};

ImplBody: Vec<ImplItem> = {
    <items:ImplItem*> => items
};

ImplItem: ImplItem = {
    FunctionDecl => ImplItem::Function(FunctionDecl),
    Token::KeywordConst Identifier "=" Expr ";" => ImplItem::Const(Identifier, Expr)
};

// ---------- Functions ----------
FunctionDecl: Decl = {
    Token::KeywordFn Identifier "(" ParamList ")" Block => Decl::Function(Identifier, ParamList, Block),
    Token::KeywordAsync Token::KeywordFn Identifier "(" ParamList ")" Block =>
        Decl::AsyncFunction(Identifier, ParamList, Block)
};

ParamList: Vec<String> = {
    /* empty */ => vec![],
    <params:Params> => params
};

Params: Vec<String> = {
    Identifier ++ ","
};

// ---------- Blocks ----------
Block: Block = {
    "{" StatementList MaybeImplicitReturn "}" =>
        Block { statements: StatementList, implicit_return: MaybeImplicitReturn }
};

StatementList: Vec<Stmt> = {
    /* empty */ => vec![],
    <list:StatementList> <stmt:Statement> => {
        let mut out = list;
        out.push(stmt);
        out
    }
};

// ---------- Statements ----------
Statement: Stmt = {
    LetDecl => <> ,
    Token::KeywordWhile Expr Block => Stmt::While { cond: Expr, body: Block },
    Token::KeywordLoop Block => Stmt::Loop { body: Block },
    Token::KeywordFor Pattern Token::KeywordIn Expr Block => Stmt::For { pattern: Pattern, iter: Expr, body: Block },
    Token::KeywordBreak ";" => Stmt::Break,
    Token::KeywordContinue ";" => Stmt::Continue,
    Token::KeywordReturn Expr ";" => Stmt::Return(<>),
    Token::KeywordMatch Expr "{" MatchArms "}" ";" => Stmt::Expr(Expr::Match { value: Box::new(Expr), arms: MatchArms }),
    Expr ";" => Stmt::Expr(<>)
};

MaybeImplicitReturn: Option<Expr> = {
    /* empty */ => None,
    Expr => Some(Expr)
};

// ---------- Let Declarations ----------
LetDecl: Stmt = {
    Token::KeywordLet MaybeMut Pattern MaybeType "=" Expr ";" =>
        Stmt::Let { mutable: MaybeMut, pattern: Pattern, ty: MaybeType, value: Expr }
};

MaybeMut: bool = {
    /* empty */ => false,
    Token::KeywordMut => true
};

MaybeType: Option<TypeExpr> = {
    /* empty */ => None,
    ":" TypeExpr => Some(TypeExpr)
};

// ---------- Patterns ----------
Pattern: Pattern = {
    Identifier => Pattern::Identifier(Identifier),
    Number => Pattern::Number(Number),
    StringLiteral => Pattern::String(StringLiteral),
    Token::Underscore => Pattern::Wildcard,
    Token::KeywordSome "(" Pattern ")" => Pattern::Some(Box::new(Pattern)),
    Token::KeywordOk "(" Pattern ")" => Pattern::Ok(Box::new(Pattern)),
    Token::KeywordErr "(" Pattern ")" => Pattern::Err(Box::new(Pattern)),
    Token::KeywordNone => Pattern::None,
    "(" PatternList ")" => Pattern::Tuple(PatternList),
    Identifier "{" FieldPatternList "}" => Pattern::Struct { name: Identifier, fields: FieldPatternList },
};

PatternList: Vec<Pattern> = {
    /* empty */ => vec![],
    Pattern ++ ","
};

FieldPatternList: Vec<(String, Pattern)> = {
    /* empty */ => vec![],
    FieldPattern ++ ","
};

FieldPattern: (String, Pattern) = {
    Identifier ":" Pattern => (Identifier, Pattern),
    Identifier => (Identifier.clone(), Pattern::Identifier(Identifier)),
};

// ---------- Expressions ----------
Expr: Expr = {
    MatchExpr => <>,
    Logic => <>
};

MatchExpr: Expr = {
    Token::KeywordMatch Expr "{" MatchArms "}" => Expr::Match { value: Box::new(Expr), arms: MatchArms },
    Logic
};

Range: Expr = {
    <a:AddSub> ".." <b:AddSub> => Expr::Call("range".into(), vec![a, b]),
    AddSub
};

Pipe: Expr = {
    Pipe "|>" Append => Expr::PipeForward(Box::new(Pipe), Box::new(Append)),
    Append
};

Append: Expr = {
    Append "++" Logic => Expr::Append(Box::new(Append), Box::new(Logic)),
    Logic
};

Logic: Expr = {
    Logic "||" Compare => Expr::Binary("||".into(), Box::new(Logic), Box::new(Compare)),
    Logic "&&" Compare => Expr::Binary("&&".into(), Box::new(Logic), Box::new(Compare)),
    Compare
};

Compare: Expr = {
    Compare "==" AddSub => Expr::Binary("==".into(), Box::new(Compare), Box::new(AddSub)),
    Compare "!=" AddSub => Expr::Binary("!=".into(), Box::new(Compare), Box::new(AddSub)),
    Compare "<" AddSub => Expr::Binary("<".into(), Box::new(Compare), Box::new(AddSub)),
    Compare ">" AddSub => Expr::Binary(">".into(), Box::new(Compare), Box::new(AddSub)),
    AddSub
};

AddSub: Expr = {
    AddSub "+" MulDiv => Expr::Binary("+".into(), Box::new(AddSub), Box::new(MulDiv)),
    AddSub "-" MulDiv => Expr::Binary("-".into(), Box::new(AddSub), Box::new(MulDiv)),
    MulDiv
};

MulDiv: Expr = {
    MulDiv "*" Unary => Expr::Binary("*".into(), Box::new(MulDiv), Box::new(Unary)),
    MulDiv "/" Unary => Expr::Binary("/".into(), Box::new(MulDiv), Box::new(Unary)),
    Unary
};

Unary: Expr = {
    "-" Unary => Expr::Unary("-".into(), Box::new(Unary)),
    "!" Unary => Expr::Unary("!".into(), Box::new(Unary)),
    Postfix
};

Postfix: Expr = {
    Postfix "++" => Expr::PostfixInc(Box::new(Postfix)),
    Primary
};

Primary: Expr = {
    "(" Expr ")" => Expr::Grouped(Box::new(Expr)),
    FunctionCall => <> ,
    Literal => <> ,
    IdentifierRef => <> ,
    Token::KeywordSome "(" Expr ")" => Expr::Some(Box::new(Expr)),
    Token::KeywordNone => Expr::None,
    Token::KeywordOk "(" Expr ")" => Expr::Ok(Box::new(Expr)),
    Token::KeywordErr "(" Expr ")" => Expr::Err(Box::new(Expr)),
};

// ---------- Function Calls ----------
FunctionCall: Expr = {
    Identifier "(" ArgList ")" => Expr::Call(Identifier, ArgList)
};

ArgList: Vec<Expr> = {
    /* empty */ => vec![],
    <args:Args> => args
};

Args: Vec<Expr> = {
    Expr ++ ","
};

// ---------- Literals ----------
Number: Expr = {
    <t:Tok> => match t {
        Token::NumberInt(n) => Expr::NumberInt(n),
        Token::NumberFloat(f) => Expr::NumberFloat(f),
        _ => panic!("Expected number")
    }
};

StringLiteral: Expr = {
    <t:Tok> => match t {
        Token::String(s) => Expr::String(s),
        _ => panic!("Expected string")
    }
};

Identifier: String = {
    <t:Tok> => match t {
        Token::Identifier(s) => s,
        _ => panic!("Expected identifier")
    }
};
