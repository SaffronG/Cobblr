<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cobblr CLI Tutorial</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #ffffff;
        color: #1a1a1a;
        margin: 0;
        padding: 0;
        line-height: 1.6;
      }
      header {
        background: #223b2a;
        padding: 20px;
        text-align: center;
        font-size: 2rem;
        font-weight: bold;
        color: #b6ffb0;
        border-bottom: 3px solid #3c5f47;
      }
      main {
        padding: 20px 15%;
      }
      h2 {
        color: #2d4a35;
        margin-top: 40px;
      }
      code,
      pre {
        background: transparent;
        padding: 0;
        margin: 0;
        border: none;
      }
      .section {
        margin-bottom: 40px;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <script>
      hljs.highlightAll();
    </script>
  </head>
  <body>
    <header>Make a simple CLI Program In Cobblr</header>
    <main>
      <div class="section">
        <p>
          Prerequisites: Basic knowledge in programming (functions variables,
          data types, etc.) This tutorial does not assume that you know Cobblr
          Syntax.
        </p>
      </div>

      <div class="section">
        <h2>Step 1: Creating a Project!</h2>
        <p>
          Cobblr uses a simple project structure with an optional config.Toml
          file. So, to start, create a folder named CLI-WC-Cobblr/. Next, you
          need to move inside of the folder (using cd ‘CLI-WC-Cobblr’) then
          create your main.cblr file.
        </p>
      </div>

      <div class="section">
        <h2>Step 2: Hello World!</h2>
        <p>
          Following the age-old standard of creating a project, let's start with
          printing “Hello World!”. In your main.cblr file add the following
          code:
        </p>
        <pre><code class="language-rust">fn main() -> () {
	std::io::println("Hello World!")
}</code></pre>
        <p>
          In the above code snippet, we define the entry point to our program,
          main, that returns an empty value, or void. Within this function we
          use the println function defined in the standard library std::io and
          output “Hello World!” to the screen. Now you’ve successfully used
          Cobblr to create a working “Hello World!” program!
        </p>
      </div>

      <div class="section">
        <h2>Step 3: Getting and using Command Args</h2>
        <p>
          Following the C-like way of handling command-line arguments, in
          Cobblr, we just use the arguments of the main function as, in order,
          the length of the parameter vector, and then the vector itself. That
          looks as follows:
        </p>
        <pre><code class="language-rust">fn main(len: int, args: Vec&lt;String&gt;) -> () {
	std::io::println("Hello World!")
}</code></pre>
        <p>
          Ok, so now that we’ve successfully read input from the command-line,
          how can we use that input? Well, we simply use the variable name that
          we defined when collecting the inputs.
        </p>
        <p>
          Lets then change our program to print “Hello &lt;name&gt;!” where
          &lt;name&gt; is whatever name the user inputs as a program argument.
          And remember, the first item in a vector of command-line arguments is
          the name of the executable file! So, we need to get the second item in
          the vector and print that. Also notice the :s within the {} curly
          braces, this indicates that we want to cast the value into a String
        </p>
        <pre><code class="language-rust">fn main (len: int, args; Vec&lt;String&gt;) -> () {
	std::io::println("Hello {:s}!", args[1])
}</code></pre>
        <p>
          Perfect! Now, if we run this program using our cobblr run main.cblr
          “Chase” command, then we will get the output:
        </p>
        <p>"Hello Chase!"</p>
      </div>

      <div class="section">
        <h2>Step 4: Using Macros for Readability</h2>
        <p>In our program we are currently using:</p>
        <p>std::io::println("Hello {:s}!, args[1])</p>
        <p>
          But Cobblr allows a very useful tool to increase readability, macros.
          There is a list of pre-defined macros for the std::lib and these are
          automatically included in a new Cobblr project; they can be ignored by
          putting the following in your config.Toml file.
        </p>
        <pre><code class="language-rust">[include]
exclude = ["std::macros::*"]</code></pre>
        <p>
          With that aside, let’s look at what the default macro for println
          looks like.
        </p>
        <pre><code class="language-rust">fn main(len: Int, args: Vec&lt;String&gt;) -> () {
	println!("Hello {:s}", args[1])
}</code></pre>
        <p>
          As you can see, the macro is denoted by using the ! bang, character
          after the function. It is recommended to use this style of macro
          definition when creating your own macros.
        </p>
      </div>

      <div class="section">
        <h2>Step 5: Error Handling</h2>
        <p>
          The more experienced programmer may have noticed our lack of error
          handling and dealing with mishandled inputs, let's see how we can deal
          with this situation.
        </p>
        <p>
          We can use a match statement here to quickly handle if there is no
          input vs one input, vs any other adverse possibility.
        </p>
        <pre><code class="language-rust">use std::Error;

fn main(len: Int, args: Vec&lt;String&gt;) -> Result&lt;(), Error&gt; {
	match len {
		(<= 1) => Err(Error::InvalidInput("No input provided1")),
		2 => (), 
		_ => Err(Error:InvalidInput("Too many inputs provided!")),
	}
	Ok(println!("Hello {:s}", args[1]))
}</code></pre>
        <p>
          As you can see, we included the library struct std::Error, this allows
          us to use Error as a return value for our verbose error handling.
        </p>
        <p>
          In our match statement, there is something that might be a shock for
          someone coming from rust, it is automatic function currying! The (<=
          1) will take the value from len and supply it as the empty value, in
          this case the left-hand input, and output true or false. A match
          statement in Cobblr will match on True, and if no function is
          provided, it will match based on equivalence.
        </p>
      </div>

      <div class="section">
        <h2>Step 6: Counting words and Outputting the value</h2>
        <p>
          Now that we have our verbose error handling, our input, we have all of
          the key pieces to finally make our word-count program work! Lets do
          this using a simple closure function and another library function
          split.
        </p>
        <p>Let's start by adding this line just before our print statement:</p>
        <pre><code class="language-rust">let wc: int = | input: String | input.split(" ").count() end;</code></pre>
        <p>
          This line of code will take our input, in this case it will be
          args[1]. Then return the count of the Vec&lt;String&gt; that is
          returned by split. Finally, that value will then be stored in the
          variable wc;
        </p>
        <p>We now have a word count for the user input!</p>
        <p>
          Now lets format this output in a user-readable way. Replace the
          previous print statement with this line:
        </p>
        <pre><code class="language-rust">Ok(println!("Word count: {wc:d}"))</code></pre>
        <p>
          This showcases one more way that the println function deals with
          formatting, if a value is supplied on the left of the : colon, it will
          use that as the value instead of the c-like string formatting. This
          can also be any arbitrary expression that provides a predictable
          output. The final program looks like this:
        </p>
        <pre><code class="language-rust">use std::Error;

fn main(len: Int, args: Vec&lt;String&gt;) -> Result&lt;(), Error&gt; {
	match len {
		(<= 1) => Err(Error::InvalidInput("No input provided1")),
		2 => (), 
		_ => Err(Error:InvalidInput("Too many inputs provided!")),
	}
	let wc: int = | input: String | input.split(" ").count() end;
	Ok(println!("Word count: {wc:d}"))
}</code></pre>
      </div>

      <div class="section">
        <h2>Step 7: Options for Further Improvements</h2>
        <p>
          Now that you’ve created your first Cobblr program, do some
          experimentation! Some suggestions for further learning are:
        </p>
        <ul>
          <li>
            If multiple inputs are provided, join them, then count the conjoined
            word-count
          </li>
          <li>Print and do the wc logic in one-line</li>
          <li>Learn more about Cobblr and the language functions</li>
          <li>Add some documentation to the language</li>
          <li>Leave a comment, question, or tutorial on the Cobblr Wiki</li>
        </ul>
      </div>
    </main>
  </body>
</html>
