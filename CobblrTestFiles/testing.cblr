use std::io::Env;

fn add(l:i32, r:i32) -> i32 {
    l + r
}

struct HttpServer {
    ip: String,
    port: i32,
}

impl HttpServer {
    fn start (self) {
        print("Server started at {0}:{1}", self.ip, self.port);
    }

    fn new (ip: string, port: i32) -> HttpServer {
        HttpServer <- ( ip: ip, port: port )
    }
}

fn square(n: i32) -> i32 {
    n * n
}

// Enum declaration
enum Types {
    Str(String),
    Boolean(Bool),
    Int(i32),
    Float(f32),
}

#derive(Debug, Clone)
struct Point {
    x: int,
    y: int,
}

struct Stack<T, G> {
    list: Vec<T>,
    union: Vec<G>,
    count: int,
}

impl Point {
    // Point Initializer
    fn new (x_point: int, y_point: int) -> Point {
        // storing Point as a temporary variable
        let p1 = Point <- ( x: x_point, y: y_point );
        // implicit return
        p1
    }
    async fn scale_immut (s: &int, scalar: int) -> Point {
        // Simply return point and construct it at the same time using implicit return and struct-builder syntax
        Point <- ( x: s.x * scalar, y: s.y * scalar )
    }
}

fn main() -> Result<String>{
    // Struct Init
    let p1 = Point::new(9,10);

    // Prepend and Append ++ operator
    let Arr: Vec<i32> = Vec::new();
    let Arr2: Vec<i32> = Vec::new();
    let combo = Arr ++ Arr2;
    Arr::scale_immut(&self, 2);

    // Index access and assignment
    //Arr[0] = 379010;

    // Closure Syntax
    let transform = (| n: int, m: int | { n * m });

    // Function calling and type assignement
    let sum: i32 = add(1,2) + 3;

    // String Concat
    print("(" ++ p1.x ++ "," ++ p1.y ++ ")");

    print(p::scale_immut(&self, 5));
    print("sum: {0} sum {1} .", p1.x, p1.y);

    // Example using the pipe forward syntax
    let equation = add(1,2) |> square;

    loop {
        let i = 0;
        if i > Arr.length {
            print("Out of range");
        }
        else {
            print(Arr[i]);
        }
    }

    // Demonstrating pattern matching with various patterns
    match Arr[0] {
        0 => { print("first item"); },
        1 => { print("second item"); },
        _ => { print("{:#?}", e); },
        Ok(value) => { value },
        Some(_) => { Err(Error::InvalidInput("Too many arguments")) },
        None => { Err(Error::InvalidInput("Invalid input")) },
        _ => { Err(Error::InvalidInput("Too many arguments")) },
    }

    // Implicit Return
    Ok(sum)
}